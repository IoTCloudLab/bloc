{
  "name": "secp256k1",
  "version": "0.0.15",
  "description": "This module provides native bindings to ecdsa secp256k1 functions",
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha --reporter spec ./test/",
    "install": "node-gyp rebuild"
  },
  "dependencies": {
    "bindings": "^1.2.1",
    "nan": "^1.4.1"
  },
  "devDependencies": {
    "bigi": "^1.3.0",
    "coinkey": "^1.3.0",
    "ecdsa": "^0.6.0",
    "mocha": "^1.21.4",
    "secure-random": "^1.1.1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/wanderer/secp256k1-node.git"
  },
  "keywords": [
    "secp256k1",
    "ecdsa",
    "ec"
  ],
  "author": {
    "name": "martin becze",
    "email": "mjbecze@gmail.com"
  },
  "contributors": [
    {
      "name": "Kagami Hiiragi",
      "email": "kagami@genshiken.org",
      "url": "http://kagami.genshiken.org/"
    },
    {
      "name": "ethers",
      "url": "https://github.com/ethers"
    }
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wanderer/secp256k1-node/issues"
  },
  "gypfile": true,
  "readme": "SYNOPSIS [![Build Status](https://travis-ci.org/wanderer/secp256k1-node.svg?branch=master)](https://travis-ci.org/wanderer/secp256k1-node)\n===\n\nThis module provides native bindings to ecdsa [secp256k1](https://github.com/bitcoin/secp256k1) functions.   \nThis library is experimental, so use at your own risk.\n\nINSTALL\n===\n\n##### from npm\n\n`npm install secp256k1`\n\n##### from git\n\n`git clone git@github.com:wanderer/secp256k1-node.git`  \n`cd secp256k1-node`  \n`git submodule init`  \n`git submodule update`  \n`npm install` \n\nNOTE: if you have the development version gmp installed secp256k1 will use it. Otherwise it should fallback to openssl. \n\nUSAGE\n===\n```javascript\n\nvar ecdsa = require('secp256k1'),\n  sr = require('secure-random'); \n\nvar privateKey = sr.randomBuffer(32);\n\n//a random message to sign\nvar msg = sr.randomBuffer(32);\n\n//get the public key in a compressed format\nvar pubKey = ecdsa.createPublicKey(privateKey, true);\n\n//sign the message\nvar sig = ecdsa.sign(privateKey, msg);\n\n//verify the signature\nif(ecdsa.verify(pubKey, msg, sig)){\n  console.log(\"valid signature\");\n}\n\n```\n\nTEST\n===\nrun `npm test`\n \nAPI\n===\n\nsecp256k1.verifySecretKey(secretKey) \n-----------------------------\nVerify an ECDSA secret key.\n\n**Parameters**\n\n* secretKey - `Buffer`, the secret Key to verify\n\n**Returns**: `Boolean`, `true` if secret key is valid, `false` secret key is invalid\n\nsecp256k1.verifyPublicKey(publicKey) \n-----------------------------\nVerify an ECDSA public key.\n\n**Parameters**\n\n* publicKey - `Buffer`, the public Key to verify\n\n**Returns**: `Boolean`, `true` if public key is valid, `false` secret key is invalid\n\nsecp256k1.sign(secretkey, msg, cb) \n-----------------------------\nCreate an ECDSA signature.\n\n**Parameters**\n\n* secretkey - `Buffer`, a 32-byte secret key (assumed to be valid)  \n* msg - `Buffer`,  a 32-byte message hash being signed \n* cb - `function`, the callback given. The callback is given the signature  \n\n**Returns**: `Buffer`, if no callback is given a 72-byte signature is returned\n\nsecp256k1.signCompact(secretKey, msg, cb) \n-----------------------------\nCreate a compact ECDSA signature (64 byte + recovery id). Runs asynchronously if given a callback\n\n**Parameters**\n* secretKey - `Buffer`, a 32-byte secret key (assumed to be valid)  \n* msg - `Buffer`, 32-byte message hash being signed  \n\n**cb**: function, the callback which is give `err`, `sig` the  \n* sig - `Buffer`   a 64-byte buffer repersenting the signature  \n* recid - `Buffer` an int which is the recovery id.  \n\n**Returns**: result only returned if no callback is given\n* result.signature\n* result.r\n* result.s\n* result.recoveryId\n\nsecp256k1.verify(pubKey, mgs, sig) \n-----------------------------\nVerify an ECDSA signature.  Runs asynchronously if given a callback\n\n**Parameters**\n* pubKey - `Buffer`, the public key\n* mgs - `Buffer`, the 32-byte message hash being verified\n* sig - `Buffer`, the signature being verified\n\n**Returns**: Integer,  \n   - 1: correct signature\n   - 0: incorrect signature\n   - -1: invalid public key\n   - -2: invalid signature\n\nsecp256k1.recoverCompact(msg, sig, recid, compressed,  cb) \n-----------------------------\nRecover an ECDSA public key from a compact signature in the process also verifing it.  Runs asynchronously if given a callback\n\n**Parameters**\n* msg - `Buffer`, the message assumed to be signed\n* sig - `Buffer`, the signature as 64 byte buffer\n* recid - `Integer`, the recovery id (as returned by ecdsa_sign_compact)\n* compressed - `Boolean`, whether to recover a compressed or uncompressed pubkey\n* cb - `function`, Recover an ECDSA public key from a compact signature. In the process also verifing it.\n\n**Returns**: Buffer, the pubkey, a 33 or 65 byte buffer\n\nsecp256k1.createPubKey(secKey, compressed) \n-----------------------------\nCompute the public key for a secret key.\n\n**Parameters**\n* secKey - `Buffer`, a 32-byte private key.\n* compressed - `Boolean`, whether the computed public key should be compressed\n\n**Returns**: Buffer, a 33-byte (if compressed) or 65-byte (if uncompressed) area to store the public key.\n\nsecp256k1.exportPrivateKey(secertKey, compressed) \n-----------------------------\n\n**Parameters**\n* secertKey - `Buffer`\n* compressed - `Boolean`\n\n** Returns**: Buffer, privateKey\n\nsecp256k1.importPrivateKey(privateKey) \n-----------------------------\n\n**Parameters**\n* privateKey - `Buffer`\n\n**Returns**: `Buffer`, secertKey\n\nsecp256k1.decompressPublickey(secretKey) \n-----------------------------\n\n**Parameters**\n* secretKey - `Buffer`\n\n**Returns**: `Buffer`, This module provides native bindings to ecdsa [secp256k1](https://github.com/bitcoin/secp256k1) functions\n\nsecp256k1.privKeyTweakAdd(secretKey) \n-----------------------------\n**Parameters**\n* privateKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: `Buffer`\n\nsecp256k1.privKeyTweakMul(privateKey, tweak) \n-----------------------------\n**Parameters**\n* privateKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: Buffer\n\nsecp256k1.pubKeyTweakAdd(publicKey, tweak) \n-----------------------------\n**Parameters**\n* publicKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: `Buffer`\n\nsecp256k1.pubKeyTweakMul(publicKey, tweak) \n-----------------------------\n**Parameters**\n* publicKey - `Buffer`\n* tweak - `Buffer`\n\n**Returns**: `Buffer`\n\nLISCENCE\n-----------------------------\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "secp256k1@0.0.15",
  "dist": {
    "shasum": "1e85faddd3a7a9e458e9c531002f03e78ae9504a"
  },
  "_from": "secp256k1@0.0.15",
  "_resolved": "https://registry.npmjs.org/secp256k1/-/secp256k1-0.0.15.tgz"
}
